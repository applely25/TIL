# SSR / CSR

**서버 사이드 렌더링(SSR)**

**클라이언트 사이드 렌더링(CSR)**

📖 렌더링 : 서버로부터 요청해서 받은 내용을 브라우저 화면에 표시해주는 것

## 클라이언트 사이드 렌드링(CSR)

서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내줌 → 클라이언트가 받아 렌더링

![img1.daumcdn.png](SSR%20CSR%201ec8cb53617e4461a5eda4f1377962ad/img1.daumcdn.png)

1. user가 website에 요청 보냄
2. CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보냄
    
    📖 CDN : 유저 요청에 ‘물리적’으로 가까운 서버에서 요청에 응답하는 방식
    
3. 클라이언트는 HTML과 JS를 다운로드 받음
    
    (유저는 아무것도 안보임)
    
4. 다운로드 된 JS가 실행, 데이터를 위한 API호출
    
    (유저들은 placeholder을 보게 됨)
    
5. 서버가 API로부터의 요청에 응답
6. API로부터 받아온 데이터를 placeholder 자리에 넣음 → 페이지는 상호작용이 가능해짐

<aside>
💡 결론
서버에서 처리 없이 클라이언트로 보내주기 때문에 자바스크립트가 모두 다운로드 되고 실행이 끝나기 전까지 사용자는 볼 수 있는게 없음

</aside>

## 서버 사이드 렌더링(SSR)

서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식

![img1.daumcdn.png](SSR%20CSR%201ec8cb53617e4461a5eda4f1377962ad/img1.daumcdn%201.png)

1. user가 website에 요청을 보냄
2. 서버는 ‘Ready to Render’(즉시 렌더링 가능한 html파일)을 만듬
    
    (리소스 체크. 컴파일 후 완성됨 HTML컨텐츠로 만듬)
    
3. 클라이언트에 전달하는 순간, HTML은 즉시 렌더링 됨(조작은 불가능 함, js가 읽히기 전)
4. 클라이언트가 js를 다운로드 받음
5. 다운 받아지는 사이 유저는 컨텐츠를 볼 수 있지만 사이트 조작은 불가능 함 → 사용자 조작을 기억하고 있음
6. 브라우저가 js프레임워크 실행
7. js 성공적으로 컴파일이 되었기 때문에 기억하던 사용자 조작이 실행 (웹 페이지 상호작용 가능)

<aside>
💡 결론
서버에서 이미 ‘렌더링 가능한’상태로 클라이언트에 전달되기 때문에, JS가 다운로드 되는 동안 사용자는 무언가를 보고 있을 수 있음

</aside>

## CSR vs SSR

### 웹페이지 로딩 시간

1. 첫 페이지 로딩 시간
    
    CSR → HTML, CSS, 모든 스크립트 한번에 불려옴
    
    SSR → 필요한 부분의 HTML과 스크립트만 불러옴
    
    **평균적으로 SSR이 더 빠름**
    
2. 나머지 로딩 시간
    
    CSR → 처음에 다 불러왔기 때문에 빠름
    
    SSR → 첫 페이지를 로딩한 과정을 정확하게 다시 실행함
    
    ****************************CSR이 더 빠름****************************
    

### SEO(검색 엔진)대응

검색엔진 → 자동화된 로봇인 ‘크롤러’로 웹 사이트들을 읽음

CSR → 자바스크립트를 실행시켜 동적으로 컨텐츠다 js가 실행되어야 metadata 바뀜

SSR → 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용함

********************************************SSR이 더 대응하기에 좋음********************************************

### 서버 자원 사용

CSR → 클라이언트에 일감을 몰아주기 때문에 서버 부하가 적음

SSR → 매번 서버에서 요청을 하기 때문에 서버 자원을 더 많이 사용함

************************************CSR이 부하가 적음************************************